%% ==================================================================
%  Description: SoC estimation using EKF based on the Thevenin model
%  Input: SoC_upd_init, the initial updated value of SoC
%         Current, the working condition current generated by current_generator.slx
%% ==================================================================

function [avr_err_EKF, std_err_EKF] = EKF_Thev(SoC_upd_init, current)
    %% Initialization -----------------------------------------------
    ts  = 1;  % smaple interval
    tr = 0.2;  % smallest time interval uesd to simulate the real SOC
    N = 6000;
    Capacity = 3;
    Rsi = 0.0037;
    Rtf = 0.0019 ;
    Ctf = 23.340;
    tao1 = Rtf * Ctf;
    Rts = 0.0035;
    Cts = 501.270;
    tao2 = Rts * Cts;
    SoC_real(1, 1) = 1;  % Initial real SoC value
    States_real = [SoC_real(1, 1); 0; 0];  % (SoC_real, Up_real, Ut_real)
    States_upd = [SoC_upd_init; 0; 0];  % (SOC_upd, Up_upd, Ut_upd)
    SoC_EKF(1,1) = SoC_upd_init;
    % Errors
    Err_EKF = zeros(1, N);
    Err_EKF(1,1) = SoC_real(1,1) - States_upd(1,1);  % Error of EKF

    % EKF parameters
    P_Cov = [1e-8 0 0; 0 1e-6 0;0 0 1e-6];  % covariance matrix
    Qs = 4e-9;  % variance of the SoC process noise
    Qu = 1e-8;  % variance of the Up process noise
    Qt = 1e-8;  % variance of the Ut process noise
    R = 1e-6;  % variance of observation noise.
    I_real = current;

    % SoC estimation process  ---------------------------------------
    for T = 2 : N
        %% Simulating the real states -------------------------------
        for t = (T-1) * ts/tr - (ts/tr - 2) : (T-1) * ts/tr + 1
            
            A2 = exp(-tr / tao1);
            A3 = exp(-tr / tao2);
            
            A =[1 0 0; 0 A2 0; 0 0 A3];  % State transformation matrix
            
            B1 = - tr / (Capacity * 3600);
            B2 = Rtf * (1 - exp(-tr / tao1));
            B3 = Rts * (1 - exp(-tr / tao2));
            B = [B1; B2; B3];  % Input control matrix
                
            States_real(:, t) = A * States_real(:, t-1) + B * I_real(1, t) + [sqrt(Qs) * randn; sqrt(Qu) * randn; sqrt(Qt) * randn];
            SoC_real(1, t) = States_real(1, t);
        end
        UOC_real = 122.4786 *States_real(1, t)^8 - 401.4734 * States_real(1, t)^7 + 485.6818 * States_real(1, t)^6 -239.2806 * States_real(1, t)^5 + 3.7304 * States_real(1, t)^4 + 44.9020 * States_real(1, t)^3 - 19.8057 * States_real(1, t)^2 + 5.0932 *States_real(1, t) + 2.8341;
        % Observed voltage/current with observation error
        UL_ob_EKF = UOC_real - States_real(2, t) - States_real(3, t) - I_real(1, t) * Rsi + sqrt(R) * randn; %Ubat
        I_ob = I_real(t) + (0.01 * Capacity) * randn;  % The observation error is too large. In fact, the performance of the Kalman Filter (KF) may even be lower than that of the Adaptive Hysteresis (AH).

        
        %% EKF process ----------------------------------------------
        % predict
        
        A2 = exp(-tr / tao1);
        A3 = exp(-tr / tao2);

        A =[1 0 0; 0 A2 0; 0 0 A3];  % State transformation matrix

        B1 = - tr / (Capacity * 3600);
        B2 = Rtf * (1 - exp(-tr / tao1));
        B3 = Rts * (1 - exp(-tr / tao2));
        B = [B1; B2; B3];  % Input control matrix
                
        States_pre = A * States_upd(:, T - 1) + B * I_ob;  % states prediction
        SoC_pre = States_pre(1, 1);  % predicted value of SoC
        Up_pre = States_pre(2, 1);  % predicted value of the polarization voltage Up
        Ut_pre = States_pre(3, 1);  % predicted value of the polarization voltage Ut
        P_Cov = A * P_Cov * A' + [Qs 0 0; 0 Qu 0; 0 0 Qt];
        UOC_pre = 122.4786 * SoC_pre^8 - 401.4734 * SoC_pre^7 + 485.6818 * SoC_pre^6 -239.2806 * SoC_pre^5 + 3.7304 * SoC_pre^4 + 44.9020 * SoC_pre^3 - 19.8057 * SoC_pre^2 + 5.0932*SoC_pre + 2.8341;
        Rsi = 0.0037;
        UL_pre = UOC_pre - Up_pre - Ut_pre - I_ob * Rsi;
        % linearization
        C1 = 8*122.4786 * SoC_EKF(1,T-1)^7 - 7*401.4734 * SoC_EKF(1,T-1)^6 + 6*485.6818 * SoC_EKF(1,T-1)^5 -5*239.2806 * SoC_EKF(1,T-1)^4 + 4*3.7304 * SoC_EKF(1,T-1)^3 + 3*44.9020 * SoC_EKF(1,T-1)^2 - 2*19.8057 * SoC_EKF(1,T-1) + 5.0932;
        C = [C1 -1 -1];
        % update
        K = P_Cov * C' * (C * P_Cov * C' + R)^(-1);  % gain
        States_upd(:, T) = States_pre + K * (UL_ob_EKF - UL_pre); % UL_ob_EKF == UL_obs
        P_Cov = P_Cov - K * C * P_Cov;
        SoC_EKF(1, T) = States_upd(1, T);
        
        %% Error ----------------------------------------------------
        Err_EKF(1, T) = SoC_real(1, t) - SoC_EKF(1, T);
    end 
    
    avr_err_EKF = mean(Err_EKF);
    std_err_EKF = std(Err_EKF,0);
    
    %% Display ------------------------------------------------------
    T = 1 : N;
    figure;
    subplot(3,1,1);
    plot(T, current(1,1:N), 'g');
    hold on;
    grid on;
    xlabel('t(s)');
    ylabel('current');
    legend('current_{Real}', 'Location', 'Best');
    subplot(3,1,2);
    plot(T, SoC_real(1, 1:(ts/tr):(N*ts/tr-1)), 'LineWidth',2);
    hold on;
    plot(T, SoC_EKF(1,1:N), '-.r');
    grid on;
    xlabel('t(s)');
    ylabel('SOC');
    legend('SoC_{Real}','SoC_{EKF}');
    subplot(3,1,3);
    plot(T, Err_EKF(1,1:N), '-.g');
    hold on;
    grid on;
    xlabel('t(s)');
    ylabel('error');
    legend('Err_{EKF}', 'Location', 'Best');


    
    

